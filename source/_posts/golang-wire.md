---
title: Dependency Injection -- Wire
toc: true
date: 2022-10-31 16:09:47
categories: golang
tags: golang
---

自從dotnet後面出了net core framework之後DI已經內建在了框架之中，體驗過了DI帶來的低耦合跟可測試性之後換個語言還是會想把DI也一起弄了；這邊是看Google - Wire的雜記。

不會有過多介紹DI本身，主要還是這個DI框架的應用。

<!-- more -->


## 在框架之前

DI是完成了S.O.L.I.D裡面的D - Dependency Inversion(控制反轉)的實現，在框架之前你完全可以透過自己寫code去完成這一點，它並不是很高深的魔法。在net core中我們幾乎是綁定了DI在我們的code裡面，這是因為在net core中的DI除了完成了控制反轉，它還帶給我們很多的方便。

譬如它高度集成框架自帶的一些工具，net core的一些工具已經透過DI集成在框架裡面方便你隨時抽換，而且官方的DI還提供了物件的Life cycle控制，你可以控制物件在啥時被實體化，複用還是每次都重新實體化。

在GOLANG寫一個簡單的DI實現其實很容易。

```go
func main() {
	log := LogToConsole{ModuleName: "TestProject"}
	repository := ProductRepository{}
	paymentService := NewPaymentService(log, repository)
	paymentService.Log.LogInfo("Test")
}

type PaymentService struct {
	Log        Logger
	Repository Repository
}

func NewPaymentService(log *LogToConsole, repository *ProductRepository) *PaymentService {
	fmt.Println(&log.ModuleName)
	return &PaymentService{
		Log:        log,
		Repository: repository,
	}
}

type Logger interface {
	LogInfo(s string)
	LogError(s string)
	LogWarning(s string)
}

type LogToConsole struct {
	ModuleName string
}

func (l *LogToConsole) LogInfo(s string) {
	fmt.Printf("%v , %v\n", l.ModuleName, s)
}

func (l *LogToConsole) LogError(s string) {
	//TODO implement me
	panic("implement me")
}

func (l *LogToConsole) LogWarning(s string) {
	//TODO implement me
	panic("implement me")
}
```

如此一來我的上層邏輯不用依賴於底層的具體實做，只要符合interface定義的我就通通可以拿來用；後續我要把LOG存到DB存到FILE還是存到哪裡，都只需要完成該interface的實做，並且一開始告知我要啥就可以了。但當專案稍具規模，這樣的寫法會越來越複雜，生成實體的factory越來越多，越來越難管理。

DI的實作主要有兩種，一種透過reflect去反射出要注入的實體；一種是透過code generate替你省下自己寫注入的時間。

Wire屬於後者。

## WIRE

準備好Wire :

> go install github.com/google/wire/cmd/wire@latest

> go get github.com/google/wire/cmd/wire@latest

在開始wire前，需要先了解兩個主題：`Provider` & `Injector`。

### Provider

用於創建組建的函數，他會把這些依賴項當作參數然後創建一個組件且返還。組件可以是一個function或者是一個object或者任何型態，只有一個限制是這個組件只能由唯一一個Provider來提供。每個Provider只能提供一種類型的組件，換句話說任何Common variable你都不應該透過Provider來傳遞，例如`int`, `bool` ...etc.

當然golang提供了type alias，有這方面的需求用type alias是一個不錯的選擇。

### Injector

wire生成injector，他會取得所有Provider寫的組件依賴，按依賴順序調用。為了生成injector，慣例上會寫`wire.go` file來定義inject func。

那因為`wire.go`定義的東西實際不會被運行，在文件上方會加註`// +build wireinject`來提示編譯器不要把這份文件也編譯了。

簡單定義一個取得config的小程序，config可能取自JSON file or YAML file，甚至來自AWS VALUT, S3 ... etc，我們需要做到可以隨時抽換；且在測試時可以輕鬆去mock以利取得config之後的後續操作。

```go
package config

type Provider interface {
	GetConfig() Setting
}

type Setting struct {
	Db  string
	Env string
}

func New() (*Setting, error) {
	configProvider := YamlConfig{}
	result := configProvider.GetConfig()
	return &result, nil
}
```

我先定義了interface，裡面只有一個GetConfig方法用來取得Config，且定義了一個結構體用來說明取到的Setting內容應該包含什麼，同時放了一個構造函數用來表示我如何取得Setting實體，這一個也就是wire中的provider。

創建一個config.Provider的實作：

```go
package config

type YamlConfig Setting

func (y *YamlConfig) GetConfig() Setting {
	return Setting{
		Db:  "ConnectionString",
		Env: "Env",
	}
}
```

定義了一個Setting的Alias專門給YamlConfig使用，並且實作config.Provider，內容就隨便寫了。

為了簡單的演示我們就這樣開始跑DI吧，我們定義一個`wire.go`文件，文件內容

```go
// +build wireinject

package main

import (
	"WireSample/config"
	"github.com/google/wire"
)

func InitializeConfig() (*config.Setting, error) {
	wire.Build(config.New)
	return &config.Setting{}, nil
}

```

這邊第一行的`// +build wireinject`明確告知編譯器在執行編譯時不會將這個文件也放入，這個文件是用來告訴wire我要注入什麼用的，唯一的func `InitializeConfig`內容很間單，告訴wire我要用什麼provider來生成實體，至於return value就給空就可以了，這算是一段prosedu code，只是用來告知用途。

在terminal執行`wire`，會生成檔案`wire_gen.go`。

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"WireSample/config"
)

// Injectors from wire.go:

func InitializeConfig() (*config.Setting, error) {
	setting, err := config.New()
	if err != nil {
		return nil, err
	}
	return setting, nil
}
```

這段code由wire自動產出，其實跟手寫的code非常相像，這邊透過你給的provider明確定義如果取得config實體。這份文件後續可以透過`go generate` or `wire`更新。

在`main.go`就可以直接這樣呼叫：

```go
package main

import (
	"fmt"
)

func main() {
	appConfig, _ := InitializeConfig()
	fmt.Println(appConfig.Env)
}
```

當然，因為這個範例的相依性只有一個，而且沒有二度三度四度的相依，所以這樣看下來wire其實沒有幫助dev省下什麼事情。但實際的專案並不是那麼單純，簡單地把情境稍微補一下再來看效果。

現在除了取得config, 我會透過config的connection string去生成db instance，透過db instance去implement repository，並且在邏輯層調用cache和repository.




## FX

FX主要是透過reflect機制去完成DI，整體的用法會比較偏向JAVA/C#，明確地會有一個Container Provider，然後塞入需要的依賴關係，再由FX去做依賴注入。

FX開宗明義地表示這個lib就是拿來服務長時間運行的服務的，典型就是web相關服務；但一般的console application也不是不能用，只是情境上他是設計給長時間運行的服務的。